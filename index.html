<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>é’“é±¼ä¹±æ–— - 8äººæ‹¥æŒ¤ç‰ˆ</title>
    <style>
        /* åŸºç¡€æ ·å¼é‡ç½® */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, "Helvetica Neue", Helvetica, Arial, sans-serif;
            touch-action: none; /* ç¦æ­¢ç¼©æ”¾å’Œæ»šåŠ¨ */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            /* æ·±æµ·æ¸å˜èƒŒæ™¯ */
            background: linear-gradient(180deg, #87CEEB 0%, #1E90FF 25%, #00008B 100%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 5;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            color: #fff;
            font-weight: 800;
            font-size: 18px;
            text-shadow: 2px 2px 0 #000;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
        }

        /* å¼¹çª—æ ·å¼ */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            pointer-events: auto;
            color: white;
            text-align: center;
        }

        .modal h1 { font-size: 32px; color: #FFD700; margin-bottom: 10px; }
        .modal p { font-size: 16px; color: #ddd; margin: 5px 0 20px; line-height: 1.5; }
        
        .btn {
            background: #ff5722;
            color: white;
            border: none;
            padding: 12px 40px;
            font-size: 20px;
            border-radius: 25px;
            font-weight: bold;
            box-shadow: 0 4px 0 #bf360c;
            cursor: pointer;
        }
        .btn:active { transform: translateY(4px); box-shadow: none; }
        .hidden { display: none !important; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div>ğŸ’° <span id="score">0</span> / <span id="target">500</span></div>
            <div>â³ <span id="time">60</span>s</div>
        </div>
    </div>

    <!-- å¼€å§‹ç•Œé¢ -->
    <div id="start-screen" class="modal">
        <h1>ğŸ£ é’“é±¼ä¹±æ–—</h1>
        <p>ç«–å± 8 äººå¤§ä¹±æ–—ï¼<br>ç‚¹å‡»å±å¹•å‡ºé’©ï¼Œåˆ«ç®¡å…¬å¹³æ€§ï¼ŒæŠ¢å°±å®Œäº†ï¼</p>
        <button class="btn" onclick="Game.start()">å¼€å§‹æŠ¢é±¼</button>
    </div>

    <!-- ç»“ç®—ç•Œé¢ -->
    <div id="end-screen" class="modal hidden">
        <h1 id="end-title">æ¸¸æˆç»“æŸ</h1>
        <p id="end-reason">...</p>
        <p>æœ€ç»ˆå¾—åˆ†: <span id="final-score">0</span></p>
        <button class="btn" onclick="Game.start()">å†æ¥ä¸€å±€</button>
    </div>
</div>

<script>
/**
 * æ¸¸æˆæ ¸å¿ƒé€»è¾‘ - 8äººä¹±æ–—ç‰ˆ
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// å±å¹•é€‚é…
let W, H;
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- æ¸¸æˆå¸¸é‡é…ç½® ---
const CONFIG = {
    anglerCount: 8,         // æ€»äººæ•°
    rowSize: 4,             // æ¯è¡Œäººæ•°
    playerIndex: 5,         // ç©å®¶ç´¢å¼• (0-3æ˜¯åæ’, 4-7æ˜¯å‰æ’, 5æ˜¯å‰æ’å·¦äºŒ)
    hookBaseSpeed: 12,      // é’©å­åŸºç¡€é€Ÿåº¦
    swingSpeed: 0.025,      // æ‘†åŠ¨é€Ÿåº¦
    spawnRate: 60,          // é±¼åˆ·æ–°é¢‘ç‡(å¸§)
};

// ç‰©å“å±æ€§å®šä¹‰
const ITEMS_DB = {
    small: { emoji: 'ğŸŸ', score: 100, weight: 1.0, speed: 2.5, radius: 15 },
    big:   { emoji: 'ğŸ¦ˆ', score: 350, weight: 3.5, speed: 1.0, radius: 28 }, // é‡ï¼Œæ…¢ï¼Œå€¼é’±
    money: { emoji: 'ğŸ’', score: 800, weight: 0.5, speed: 4.0, radius: 12 }, // æå¿«ï¼Œè½»ï¼Œéš¾ç„
    trash: { emoji: 'ğŸ‘¢', score: 10,  weight: 7.0, speed: 0.6, radius: 20 }  // æé‡ï¼Œåƒåœ¾
};

// --- ç±»å®šä¹‰ ---

class Angler {
    constructor(index) {
        this.index = index;
        this.isPlayer = (index === CONFIG.playerIndex);
        
        // è®¡ç®—è¡Œå·å’Œåˆ—å·
        const row = Math.floor(index / CONFIG.rowSize); // 0=åæ’(ä¸Š), 1=å‰æ’(ä¸‹)
        const col = index % CONFIG.rowSize;
        
        // å¸ƒå±€è®¡ç®—ï¼šä¸¤è¡Œæ’åˆ—
        // åæ’(row0) Yåæ ‡è¾ƒå°ï¼Œå‰æ’(row1) Yåæ ‡è¾ƒå¤§
        this.y = row === 0 ? H * 0.06 : H * 0.14; 
        // Xåæ ‡å‡åŒ€åˆ†å¸ƒ
        this.x = (W / (CONFIG.rowSize + 1)) * (col + 1);
        
        // é¢œè‰²åŒºåˆ†
        this.color = this.isPlayer ? '#FFD700' : (row === 0 ? '#555' : '#888'); // ç©å®¶é‡‘è‰²ï¼Œåæ’æ·±ç°ï¼Œå‰æ’æµ…ç°
        
        // ç‰©ç†çŠ¶æ€
        this.angle = Math.PI / 2; // åˆå§‹å‘ä¸‹
        this.swingDir = Math.random() > 0.5 ? 1 : -1;
        this.state = 0; // 0:æ‘†åŠ¨, 1:å‘å°„, 2:æ‹‰å›, 3:æš‚åœ
        
        this.lineLen = 20;
        this.maxLen = H * 1.1; // ç¨å¾®è¶…å‡ºå±å¹•
        this.caughtItem = null;
        
        // AI éšæœºæ€§
        this.aiTimer = Math.random() * 100;
    }

    update() {
        // 1. æ‘†åŠ¨çŠ¶æ€
        if (this.state === 0) {
            const limit = 0.4; // é™åˆ¶æ‘†åŠ¨è§’åº¦ï¼Œé˜²æ­¢ç”©åˆ°å¤©ä¸Š
            if (this.angle > Math.PI - limit) this.swingDir = -1;
            if (this.angle < limit) this.swingDir = 1;
            this.angle += CONFIG.swingSpeed * this.swingDir;
            
            // AI è‡ªåŠ¨å°„å‡»
            if (!this.isPlayer) {
                this.aiTimer--;
                if (this.aiTimer <= 0) {
                    this.shoot();
                    this.aiTimer = Math.random() * 120 + 40; // é‡ç½®AIæ€è€ƒæ—¶é—´
                }
            }
        }
        // 2. å‘å°„çŠ¶æ€
        else if (this.state === 1) {
            this.lineLen += CONFIG.hookBaseSpeed;
            
            // è®¡ç®—é’©å­å°–ç«¯åæ ‡
            const tx = this.x + Math.cos(this.angle) * this.lineLen;
            const ty = this.y + Math.sin(this.angle) * this.lineLen;
            
            // è¾¹ç•Œ/ç©ºé’©åˆ¤å®š
            if (this.lineLen >= this.maxLen || tx < 0 || tx > W) {
                this.state = 3; // è¿›å…¥æš‚åœ
                this.pauseTimer = 30; // åœé¡¿0.5ç§’(30å¸§)
            } else {
                // ç¢°æ’æ£€æµ‹ (åªæ£€æµ‹æœªè¢«æŠ“çš„ç‰©å“)
                for (let item of Game.items) {
                    if (!item.caught && Math.hypot(tx - item.x, ty - item.y) < item.radius + 5) {
                        // æŠ“åˆ°äº†ï¼
                        item.caught = true;
                        this.caughtItem = item;
                        this.state = 2; // è¿›å…¥æ‹‰å›
                        if(this.isPlayer) Game.addEffect(tx, ty, "æŠ“ä½!");
                        break;
                    }
                }
            }
        }
        // 3. æš‚åœçŠ¶æ€ (ç©ºé’©æƒ©ç½š)
        else if (this.state === 3) {
            this.pauseTimer--;
            if (this.pauseTimer <= 0) this.state = 2; // å¼€å§‹å›æ”¶
        }
        // 4. æ‹‰å›çŠ¶æ€
        else if (this.state === 2) {
            let speed = CONFIG.hookBaseSpeed * 1.5; // ç©ºé’©å›æ”¶å¾ˆå¿«
            if (this.caughtItem) {
                speed = CONFIG.hookBaseSpeed / this.caughtItem.weight; // æ ¹æ®é‡é‡å‡é€Ÿ
                // æ›´æ–°ç‰©å“ä½ç½®
                this.caughtItem.x = this.x + Math.cos(this.angle) * this.lineLen;
                this.caughtItem.y = this.y + Math.sin(this.angle) * this.lineLen;
            }
            
            this.lineLen -= speed;
            
            if (this.lineLen <= 20) {
                // å›æ”¶å®Œæˆ
                this.lineLen = 20;
                this.state = 0;
                if (this.caughtItem) {
                    // ç»“ç®—
                    if (this.isPlayer) {
                        Game.score += this.caughtItem.score;
                        Game.addEffect(this.x, this.y + 40, `+${this.caughtItem.score}`);
                    }
                    // ä»æ•°ç»„ä¸­å½»åº•ç§»é™¤
                    Game.items = Game.items.filter(i => i !== this.caughtItem);
                    this.caughtItem = null;
                }
            }
        }
    }

    shoot() {
        if (this.state === 0) this.state = 1;
    }

    draw() {
        const tx = this.x + Math.cos(this.angle) * this.lineLen;
        const ty = this.y + Math.sin(this.angle) * this.lineLen;

        // ç”»çº¿
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(tx, ty);
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.isPlayer ? 3 : 1.5;
        ctx.stroke();

        // ç”»é’©å­
        ctx.beginPath();
        ctx.arc(tx, ty, 5, 0, Math.PI * 2);
        ctx.fillStyle = this.isPlayer ? 'red' : '#333';
        ctx.fill();

        // ç”»äºº (Emoji)
        ctx.font = "24px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        let avatar = this.isPlayer ? "ğŸ¤ " : "ğŸ¤–";
        ctx.fillText(avatar, this.x, this.y - 15);
        
        // ç©å®¶é«˜äº®æŒ‡ç¤º
        if (this.isPlayer) {
            ctx.fillStyle = "#FFFF00";
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - 45);
            ctx.lineTo(this.x - 8, this.y - 55);
            ctx.lineTo(this.x + 8, this.y - 55);
            ctx.fill();
        }
    }
}

class Item {
    constructor() {
        // éšæœºç±»å‹æƒé‡
        const r = Math.random();
        let type;
        if (r < 0.1) type = ITEMS_DB.money;      // 10%
        else if (r < 0.25) type = ITEMS_DB.trash; // 15%
        else if (r < 0.55) type = ITEMS_DB.big;   // 30%
        else type = ITEMS_DB.small;              // 45%

        Object.assign(this, type);
        
        // å…³å¡éš¾åº¦åŠ æˆï¼šé±¼æ¸¸å¾—æ›´å¿«
        this.speed *= (1 + (Game.level - 1) * 0.15);

        // éšæœºæ·±åº¦ (é¿å¼€é¡¶éƒ¨é’“é±¼è€…åŒºåŸŸ)
        this.y = Math.random() * (H - 200) + 180;
        
        // éšæœºæ–¹å‘
        this.dir = Math.random() > 0.5 ? 1 : -1;
        this.x = this.dir === 1 ? -50 : W + 50;
        
        this.caught = false;
    }

    update() {
        if (!this.caught) {
            this.x += this.speed * this.dir;
        }
        // æ¸¸å‡ºå±å¹•é”€æ¯
        if ((this.dir === 1 && this.x > W + 60) || (this.dir === -1 && this.x < -60)) {
            return false;
        }
        return true;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        // æ–¹å‘ç¿»è½¬
        if (this.dir === -1 && !this.caught) ctx.scale(-1, 1);
        // è¢«æŠ“æŒ£æ‰æ•ˆæœ
        if (this.caught) ctx.rotate(Math.sin(Date.now()/100)*0.5);
        
        ctx.font = `${this.radius * 2}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.emoji, 0, 0);
        ctx.restore();
    }
}

// æµ®åŠ¨æ–‡å­—ç‰¹æ•ˆ
class Effect {
    constructor(x, y, text) {
        this.x = x; this.y = y; this.text = text;
        this.life = 40;
    }
    update() { this.y -= 1; this.life--; }
    draw() {
        ctx.fillStyle = `rgba(255, 255, 255, ${this.life/40})`;
        ctx.font = "bold 20px Arial";
        ctx.fillText(this.text, this.x, this.y);
    }
}

// --- æ¸¸æˆä¸»æ§åˆ¶å™¨ ---

const Game = {
    anglers: [],
    items: [],
    effects: [],
    loopId: null,
    timerId: null,
    score: 0,
    target: 500,
    time: 60,
    level: 1,
    frameCount: 0,
    isPlaying: false,

    start() {
        this.score = 0;
        this.level = 1;
        this.target = 500;
        this.time = 60;
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('end-screen').classList.add('hidden');
        this.initLevel();
        this.isPlaying = true;
        this.run();
        
        clearInterval(this.timerId);
        this.timerId = setInterval(() => {
            if(!this.isPlaying) return;
            this.time--;
            if(this.time <= 0) this.checkEnd();
        }, 1000);
    },

    initLevel() {
        this.anglers = [];
        this.items = [];
        this.effects = [];
        // åˆå§‹åŒ–8åé’“é±¼è€…
        for(let i=0; i<CONFIG.anglerCount; i++) {
            this.anglers.push(new Angler(i));
        }
        // åˆå§‹ç”Ÿæˆä¸€æ³¢é±¼
        for(let i=0; i<8; i++) this.items.push(new Item());
    },

    nextLevel() {
        this.level++;
        this.target = Math.floor(this.target * 1.5);
        this.time = 60;
        alert(`ğŸ‰ é€šå…³æˆåŠŸï¼è¿›å…¥ç¬¬ ${this.level} å…³\nç›®æ ‡åˆ†æ•°: ${this.target}`);
        this.initLevel(); // é‡ç½®åœºä¸Šç‰©å“
    },

    checkEnd() {
        if (this.score >= this.target) {
            this.nextLevel();
        } else {
            this.gameOver();
        }
    },

    gameOver() {
        this.isPlaying = false;
        clearInterval(this.timerId);
        document.getElementById('end-screen').classList.remove('hidden');
        document.getElementById('end-reason').innerText = "æ—¶é—´åˆ°ï¼Œç›®æ ‡æœªè¾¾æˆ...";
        document.getElementById('final-score').innerText = this.score;
        cancelAnimationFrame(this.loopId);
    },

    addEffect(x, y, text) {
        this.effects.push(new Effect(x, y, text));
    },

    run() {
        if (!this.isPlaying) return;

        ctx.clearRect(0, 0, W, H);
        
        // 1. UI æ›´æ–°
        document.getElementById('score').innerText = this.score;
        document.getElementById('target').innerText = this.target;
        document.getElementById('time').innerText = this.time;

        // 2. ç”Ÿæˆæ–°é±¼
        this.frameCount++;
        if (this.frameCount % CONFIG.spawnRate === 0 && this.items.length < 15) {
            this.items.push(new Item());
        }

        // 3. æ›´æ–°ç‰©å“
        this.items = this.items.filter(item => {
            if(item.caught) return true; // ä¿æŒå¼•ç”¨
            return item.update();
        });
        // ç»˜åˆ¶ç‰©å“ (å…ˆç”»ç‰©å“ï¼Œä¿è¯è¢«é’©å­ç›–ä½)
        this.items.forEach(item => { if(!item.caught) item.draw(); });

        // 4. æ›´æ–°ä¸ç»˜åˆ¶é’“é±¼è€…
        // å…³é”®é€»è¾‘ï¼šå…ˆç”»åæ’(index 0-3)ï¼Œå†ç”»å‰æ’(index 4-7)ï¼Œåˆ¶é€ é®æŒ¡å…³ç³»
        // ç”±äºå¸ƒå±€æ˜¯ index 0-3 row0, 4-7 row1
        this.anglers.forEach(angler => angler.update());
        
        // æ’åºç»˜åˆ¶ï¼Œä¿è¯å±‚çº§æ­£ç¡®
        const sortedAnglers = [...this.anglers].sort((a, b) => a.y - b.y);
        
        sortedAnglers.forEach(angler => {
            angler.draw();
            if(angler.caughtItem) angler.caughtItem.draw(); // ç»˜åˆ¶è¢«æŠ“çš„ç‰©å“
        });

        // 5. ç‰¹æ•ˆ
        this.effects = this.effects.filter(e => e.life > 0);
        this.effects.forEach(e => { e.update(); e.draw(); });

        this.loopId = requestAnimationFrame(() => this.run());
    }
};

// äº¤äº’äº‹ä»¶
function handleInput(e) {
    if (!Game.isPlaying) return;
    e.preventDefault(); // é˜²æ­¢åŒå‡»æ”¾å¤§
    const player = Game.anglers[CONFIG.playerIndex];
    player.shoot();
}

canvas.addEventListener('mousedown', handleInput);
canvas.addEventListener('touchstart', handleInput, {passive: false});

</script>
</body>
</html>